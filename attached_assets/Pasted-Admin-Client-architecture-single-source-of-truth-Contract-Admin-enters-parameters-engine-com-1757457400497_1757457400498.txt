Admin → Client architecture (single source of truth)

Contract: Admin enters parameters → engine computes → Admin presses “Generate proposal” → server writes a proposals row (inputs + results + options) → returns a secure token URL /proposal/[token] that renders a client-safe subset of the stored results. This mirrors the project’s 2-part architecture and 24-hour plan.

Key references:

Package summary & two-app intent

SSOT formulas & outputs (budgets, hours, fees, options)

Directory & page map (admin vs client)

What is visible where
Layer	What we show	What we never show (client)
Admin (/admin/calculator)	All inputs, all calculations, fee tables, hours by phase/role, sliders, debug notices	—
Client (/proposal/[token])	Option A/B/C cards (A first), budget donuts (client-safe buckets), value copy, 3D/Nira, CTA	Hours, rates, internal fee tables, discount slider, discipline rates/splits, markup/profit

This is explicitly required across docs (Chris Do rules + client-safe narrative).

Data model & API contracts
Tables (Supabase)

Use the schema already specified (add if missing):

building_cost_data (cost ranges, default shares)

category_multipliers

proposals (stores admin inputs + full SSOT results + client options)

proposal_events (analytics)

Tokenized client links

Token: 32 bytes base64url (server-generated) stored on proposals.token.

Client page loads by token; API serves client-safe JSON only (see “client payload” below).

Add RLS policy or server gating so reads happen only by token (or via server route).

File-level implementation plan
1) Admin calculator (complete view)

Route: app/admin/calculator/page.tsx (already present, expand it)

Components to wire (names align with your structure):

components/admin/ProjectSetupForm.tsx – Use/type inputs from /lib/types.ts; debounce 300 ms.

components/admin/CostRangeSliders.tsx – Anchor min/target/max to building_cost_data.

components/admin/BudgetAllocationCard.tsx – Render Shell/Interior/Landscape with $+% and normalized shares (defaults 66/22/12).

components/admin/DisciplineCards.tsx – Shell → disciplines; Architecture = remainder; add expanders for New/Remodel split.

(Add) components/admin/FeeComparison.tsx – Top-Down (market % per scope) vs Bottom-Up (hours × blended cost); Contract = max(discounted market, LA); admin-only discount slider ≤ 25 %.

(Add) components/admin/HoursBreakdown.tsx – Phase bars and role donut from the non-linear hours formula; admin-only.

components/admin/ProposalExport.tsx – “Generate Proposal” → POST to /api/proposals to create a row and return the client token URL.

Engine calls: Use /lib/calculations.ts and constants as SSOT (no math in components).

Acceptance checks: Dr. De Jesús fixture: total budget $859,365; Shell 66 % etc.; hours/fees per SSOT or Excel mode (you already support calibration).

2) Proposal generation (server)

Route: app/api/proposals/route.ts (CRUD)
On POST:

Validate inputs (types from /lib/types.ts).

Re-compute with SSOT engine.

Persist to proposals as JSON blobs: {project_data, calculations, options}.

Return {token}. Optionally email or copy link.

Analytics: app/api/proposals/[id]/events → insert proposal_events rows (opened, option_viewed, accepted).

3) Client proposal (client-safe)

Route: app/proposal/[token]/page.tsx
Client payload (what the page loads by token):

{
  client: { name, projectName, location },
  headlineCopy, heroImage,
  options: { A, B, C },                 // investments & scopes (no hours)
  budgetSummary: { shell, interior, landscape }, // totals only
  charts: { dataForDonut },             // client-safe buckets
  proofs: { niraModelIds, renders },    // optional
  cta: { primary, secondary }
}


Do not include: hours, market vs LA fee tables, rates, sliders, multipliers.
Components: components/client/OptionComparison.tsx, BudgetDonut.tsx, ProofOfPrecision.tsx, ConversionCTA.tsx.

Copy: Use value-based language + A-first anchoring; the content agent can pull from copy-content.json as declared.

Security & compliance

Token security & RLS: enforce token-based reads (or always fetch via server route).

Client transforms: server trims the stored JSON → client-safe payload (never ship admin internals).

No hours/rates on client: audited in Requirements and Agent Prompts; add unit/Playwright checks for this rule.

Visual & UX standards (premium, mobile-first)

Use brand palette, spacing, and chart standards from Design Guidelines (donut config, card patterns, option emphasis with A highlighted).

Admin = two-column; Client = single-column narrative flow.

Performance: <3 s load on mobile, <300 ms calc updates.

Deliverables the agent should ship (checklist)
Admin (internal)

 FeeComparison (Top-Down vs Bottom-Up) with contract tile + discount slider

 HoursBreakdown (phase + role)

 DisciplineCards with Architecture-as-remainder + expanders

 BudgetAllocationCard showing both % and $, normalized to 100 %

 ProposalExport creating a token URL via /api/proposals

Client (public)

 /proposal/[token] page that renders only: Option A/B/C (A first), budget donut, value copy, Nira section, CTA

 No hours/rates/internal math in the rendered HTML/JSON (automated QA rule)

Platform

 DB schema + envs (Supabase) online

 Analytics events for view/option-view/accept

 Smoke & functional checks from the deployment checklist

QA & acceptance gates

Math parity: SSOT test(s) pass for Dr. De Jesús numbers (budget & SSOT hours/fees).

Client-safety tests: In /tests, assert the client route never renders “hour”, “rate”, “overhead”, “discount”, “contract”, etc. (Requirements & Prompts demand it).

Performance: Lighthouse mobile ≥90; <3 s TTI; charts <500 ms render.

UX: A/B/C with A first; value copy; progressive disclosure; mobile-first layout.

Why this matches the repo plan

It directly implements the two-part system the docs describe (Admin calculator → Client proposal).

It uses the SSOT calculation engine (/lib/calculations.ts) and keeps UI free of re-math (design goal across docs).

It follows the directory structure so multiple agents can move in parallel without collisions.

It enforces Chris Do principles and the “no hourly to clients” rule across the client path (explicit, non-negotiable).

Immediate next tasks for the agent (do these now)

Add FeeComparison.tsx and HoursBreakdown.tsx to Admin and wire to /lib/calculations.ts outputs (no UI math).

Implement /api/proposals (POST) to persist admin input/results and return { token }.

Build /proposal/[token] route that fetches a client-safe payload and renders OptionComparison, BudgetDonut, ProofOfPrecision, ConversionCTA only.

Add QA checks from Deployment Checklist / Requirements for math parity, client-safety, and performance.

If you want, I can draft the minimal server code for /api/proposals and the client-safe payload transformer next.

(All guidance above is grounded in your repo’s development package, directory structure, SSOT formulas, design system, and acceptance criteria.)